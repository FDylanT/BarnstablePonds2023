---
title: "Pond Shiny"
date: "2023-09-20"
runtime: shiny
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = "~/Desktop/Repos/BarnstablePonds2023")
```

```{r include = FALSE}
### Load packages

library(tidyverse)
library(gsw)
library(trend)
library(egg)
library(DT)
library(pals)
library(sf)
library(viridis)
```

```{r include = FALSE}
### Load data

setwd("~/Desktop/Repos/BarnstablePonds2023")

#ponds_full <- read.csv("data/072523_CC_AllPonds_WQ.csv", header = TRUE) %>%
ponds_full <- read.csv("data/09132023_CC_AllPonds_WQ.csv", header = TRUE) %>%
  
  # remove non-data rows
  filter(Station.name != "") %>%
  
  # remove quality code columns for easier visualization
  dplyr::select(-Quality.code, -Quality.code.1, -Quality.code.2, -Quality.code.3, -Quality.code.4,
                -Quality.code.5,
         -Quality.code.6, -Quality.code.7, -Quality.code.8, -Quality.code.9, -Quality.code.10,
         -Quality.code.11, -Quality.code.12, -Quality.code.13, -Quality.code.14, -Quality.code.15,
         -Quality.code.16, -Quality.code.17, -Quality.code.18, -Quality.code.19, -Quality.code.20,
         -Quality.code.21, -Quality.code.22, -Quality.code.23, -Quality.code.24, -Quality.code.25,
         -Quality.code.26, -Quality.code.27, -Quality.code.28, -Quality.code.29, -Quality.code.30,
         -Quality.code.31, -Quality.code.32, -Quality.code.33, -Quality.code.34, -Quality.code.35,
         -Quality.code.36, -Quality.code.37, -Quality.code.38)
```

```{r include = FALSE}
### Merge same-parameter columns & reorganize data frame

ponds <- ponds_full %>%
  unite(Secchi, Secchi.Depth...SECCHI, Secchi.Depth...SECCHI.1, sep = "") %>%
  unite(Temp, Water.Temperature...TEMP, Water.Temperature...TEMP.1, sep = "") %>%
  unite(DO, Dissolved.Oxygen...Reported...DO, Dissolved.Oxygen...Reported...DO.1, sep = "") %>%
  unite(DO_sat, Dissolved.Oxygen.Saturation...Reported...DO_SAT,
        Dissolved.Oxygen.Saturation...Reported...DO_SAT.1, sep = "") %>%
  unite(Alk, Alkalinity...ALK, Alkalinity...ALK.1, sep = "") %>%
  unite(pH, pH...PH, pH...PH.1, pH...PH.2, sep = "") %>%
  unite(TP, Total.Phosphorus...TP, Total.Phosphorus...TP.1, sep = "") %>%
  unite(TN, Total.Nitrogen...Reported...TN, Total.Nitrogen...Reported...TN.1, sep = "") %>%
  unite(Chla, Chlorophyll...CHLA, Chlorophyll...CHLA.1, sep = "") %>%
  unite(Phaeo, Phaeophytin...PHAEO, Phaeophytin...PHAEO.1, sep = "") %>%
  unite(Sal, Salinity...SAL, Salinity...SAL.1, sep = "") %>%
  
  # remove unneeded columns
  dplyr::select(-Sample.number, -Depth.Designation) %>%
  
  # split long/lat coordinates
  separate_wider_delim(Long.lat.coordinates, " / ", names = c("Long", "Lat"), too_few = "align_start") %>%
  
  # rename columns with redundant headers
  rename(Total.Depth = Total.Depth...DTB,
         TP_ugL = Total.Phosphorus...micrograms.per.liter...TP_ugL,
         CTI_TP = Carlson.Trophic.Index...Total.Phosphorus.based...CTI_TP,
         CTI_Chlorophyll = Carlson.Trophic.Index...Chlorophyll.a.based...CTI_CHLA,
         CTI_Secchi = Carlson.Trophic.Index...Secchi.Depth.Based...CTI_SD,
         ATemp = Air.Temperature...AT,
         NH4 = Ammonium...NH4,
         DO_Final = Dissolved.Oxygen.Concentration...Final...DO_FINAL,
         DO_sat_Final = Dissolved.Oxygen.Saturation...Final...DO_SAT_FINAL,
         NOX = Nitrate...Nitrite...NOX,
         PO4 = Orthophosphate...PO4,
         ORP = Oxidation.Reduction.Potential...ORP,
         Wind = Qualitative.Wind.Description...WIND,
         Cond = Specific.Conductivity...COND,
         TDS = Total.Dissolved.Solids...TDS,
         TPigm = Total.Pigments...TOTAL_PIGMENTS) %>%
  
  # reorder columns
  relocate(Temp, .before = DO) %>%
  relocate(DO_sat, .after = DO) %>%
  relocate(pH, .after = DO_sat) %>%
  relocate(Alk, .after = pH) %>%
  relocate(Chla, .after = TN) %>%
  relocate(Phaeo, .after = Chla) %>%
  relocate(NOX, .after = NH4) %>%
  
  # extract date from date-time column & create new column
  mutate(Date = str_extract(Date.Time..sampling., "\\d+/\\d+/\\d+"),
         Time = str_extract(Date.Time..sampling., "\\d{1,2}:\\d{2}")) %>%
  
  # extract month and year from date-time column & create new column
  mutate(Month = str_extract(Date.Time..sampling., "\\d{1,2}(?=/)"),
         Year = paste("20", str_extract(Date.Time..sampling., "(?<=\\d{1,2}/\\d{1,2}/)\\d+"), sep = "")) %>%
  
  # prepare columns for reordering ponds in dropdown menu
  mutate(Town = str_extract(Station.number, "[A-Z]{2}")) %>%
  mutate(Pond.number = as.numeric(str_extract(Station.number, "\\d+"))) %>%
  mutate(Station.name = paste(Station.number, "/", Site))

ponds[ponds == "MA-634-01 / Mashpee-Wakeby Pond"] <- "MA-634-01 / Mashpee Lake"
ponds[ponds == "MA-1039-01 / Mashpee-Wakeby Pond"] <- "MA-1039-01 / Wakeby Pond"

# convert all empty cells to NA
ponds[ponds == ""] <- NA

# convert null datapoints to NA
ponds[ponds == "n.m. 0.00"] <- NA
ponds[ponds == "ND 0.00"] <- NA
ponds[ponds == "<MDL 0.00"] <- NA
ponds[ponds == "BDL 0.00"] <- "0"

# temporarily fix non-numeric datapoints
ponds[ponds == "-0.04"] <- "0.04"
ponds[ponds == "-0.3"] <- "0.3"
ponds[ponds == "> 15.50"] <- "15.50"
ponds[ponds == "< 0.05"] <- "0"
ponds[ponds == "< 0.10"] <- "0"
ponds[ponds == "< 1.50"] <- "1.50"

# fix missing decimal
ponds[ponds == "207"] <- "20.7"

# temporarily remove problematic row
ponds <- ponds[-which(ponds$pH == "n.m. 6.83"), ]

# convert all numerical cols to numeric
is_all_numeric <- function(x) {
  !any(is.na(suppressWarnings(as.numeric(na.omit(x))))) & is.character(x)
}
ponds <- ponds %>% 
  mutate_if(is_all_numeric, as.numeric)

#str(ponds)
```

```{r echo = FALSE}
## calculate DO saturation values (*in future should come from WISKI)
for(i in 1:nrow(ponds)) {
  if(is.na(ponds$DO_sat[i])) {
    rho <- gsw_rho(0, ponds$Temp[i], ponds$Depth) # kg/m^3
    ponds$DO_sat[i] <- ponds$DO[i] / 32 / rho * 10^6 /
                        gsw_O2sol(0, ponds$Temp[i], ponds$Depth[i], ponds$Long[i], ponds$Lat[i]) * 100
  }
}

#mg/L to um/kg

#mg/L * 1000L/m^3 = mg/m^3 * 1g/1000mg = g/m^3 * 1mol/15.999g = mol/m^3 * 1/rho m^3/kg = mol/kg * 1,000,000 umol/mol

# calculate DO concentration values
ponds$DO_con <- NA

for(i in 1:nrow(ponds)) {
  rho <- gsw_rho(0, ponds$Temp[i], ponds$Depth) # kg/m^3
  ponds$DO_con[i] <- gsw_O2sol(0, ponds$Temp[i], ponds$Depth[i], ponds$Long[i], ponds$Lat[i]) / 100 *
                    ponds$DO[i] * 32 * rho / 10^6
}

ponds <- ponds %>%
  relocate(DO_con, .after = DO_sat)
```

```{r echo = FALSE}
ponds <- ponds %>%
  filter(Month == 8 | Month == 9) %>%
  arrange(Town, Pond.number)

pondName <- unique(ponds$Station.name)

selectInput("pond", label = "Choose pond:", choices = pondName)
```

```{r include = FALSE}
## Match ponds to metadata
setwd("~/Desktop/Repos/BarnstablePonds2023")
chars <- read.csv("data/PondCharacteristics.csv")

ponds$Final.Depth.ft <- NA
ponds$Final.Depth <- NA
ponds$Size <- NA
ponds$Lens <- NA
ponds$PercentBuffer <- NA
ponds$BufferClass <- NA

for(i in 1:nrow(ponds)) {
  ID <- str_extract(ponds$Station.number[i], "[A-Z]{2}-\\d+")
  if(length(chars$Final.Depth[chars$CCC_GIS_ID == ID]) > 0) {
    ponds$Final.Depth.ft[i] <- as.numeric(chars$Final.Depth[chars$CCC_GIS_ID == ID])
    ponds$Final.Depth[i] <- ponds$Final.Depth.ft[i] * 12 / 39
    ponds$Size[i] <- as.numeric(chars$Acres[chars$CCC_GIS_ID == ID])
    ponds$Lens[i] <- chars$Aquifer.Lens[chars$CCC_GIS_ID == ID]
    ponds$PercentBuffer[i] <- chars$X..100ft.buffer.developed[chars$CCC_GIS_ID == ID]
    ponds$BufferClass[i] <- chars$buffer.development.class[chars$CCC_GIS_ID == ID]
  }
}

ponds <- ponds %>%
  mutate(DepthClass = case_when(Final.Depth < 3 ~ "Shallow",
                                Final.Depth > 3 ~ "Deep"))

ponds$SizeClass <- NA

# ponds_grouped <- ponds %>%
#   group_by(Station.name) %>%
#   summarize(Size = mean(Size))
# 
# quantile(ponds_grouped$Size, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

ponds$SizeClass <- case_when(ponds$Size <= 5.743542 ~ "Very Small",
                             ponds$Size <= 12.315432 ~ "Small",
                             ponds$Size <= 32.563650 ~ "Medium",
                             ponds$Size > 32.563650 ~ "Large")

#unique(ponds$Station.number[is.na(ponds$Final.Depth)])
```

```{r echo = FALSE}
ponds$Temp_flag <- NA
ponds$DO_flag <- NA

clim_all <- data.frame(matrix(ncol = 6, nrow = 2500))
colnames(clim_all) <- c("Station.name", "Depth", "Temp", "Temp_sd", "DO", "DO_sd")

for(pond in pondName) {
  onePond <- ponds %>%
    filter(Station.name == pond,
           !is.na(Depth))
  onePond$Depth[onePond$Depth == 0] <- 0.01
  clim <- data.frame(matrix(ncol = 5, nrow = length(1:ceiling(max(onePond$Depth)))))
  colnames(clim) <- c("Depth", "Temp", "Temp_sd", "DO", "DO_sd")
  for(param in c("Temp", "DO")) {
    clim$Depth[1:length(1:ceiling(max(onePond$Depth)))] <- 1:ceiling(max(onePond$Depth))
    clim.v <- rep(NA, nrow(clim))
    clim.v2 <- rep(NA, nrow(clim))
    for(i in 1:length(clim$Depth)) {
      clim1 <- mean(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i],
                    na.rm = TRUE)
      clim.v[clim$Depth == i] <- clim1
      clim2 <- sd(onePond[[param]][onePond$Depth >= i - 0.99 & onePond$Depth <= i], na.rm = TRUE)
      clim.v2[clim$Depth == i] <- clim2
    }
    clim[[param]][1:length(clim.v)] <- clim.v
    param_sd <- paste0(param, "_sd")
    clim[[param_sd]][1:length(clim.v2)] <- clim.v2
    clim[[param_sd]] <- ifelse(is.na(clim[[param_sd]]), 0, clim[[param_sd]])
    flag_name <- paste0(param, "_flag")
    for(j in 1:nrow(onePond)) {
      depth <- ceiling(onePond$Depth[j])
      m <- clim[[param]][clim$Depth == depth]
      sd <- clim[[param_sd]][clim$Depth == depth]
      if(is.na(onePond[[param]][j])) {
        onePond[[flag_name]][j] <- 4
      } else if(onePond[[param]][j] >= m - 3*sd & onePond[[param]][j] <= m + 3*sd) {
        onePond[[flag_name]][j] <- 2
      } else {
        onePond[[flag_name]][j] <- 3
      }
    }
    ponds[[flag_name]][ponds$Station.name == pond & !is.na(ponds$Depth)] <- onePond[[flag_name]]
  }
  clim_all[sum(!is.na(clim_all$Station.name)) + 1:nrow(clim), 2:6] <- clim
  clim_all$Station.name[sum(!is.na(clim_all$Station.name)) + 1:nrow(clim)] <- pond
}

clim_all <- clim_all %>%
  filter(!is.na(Station.name))

ponds$Temp_anom <- NA
ponds$DO_anom <- NA

for(i in 1:nrow(ponds)) {
  pond <- ponds$Station.name[i]
  if(is.na(ponds$Depth)[i]) {
    next
  }
  if(ponds$Depth[i] == 0) {
    a <- 0.01
    b <- 1
  } else if(ponds$Depth[i] %% 1 != 0){
    a <- floor(ponds$Depth[i]) + 0.01
    b <- ceiling(ponds$Depth[i])
  } else {
    a <- floor(ponds$Depth[i])
    b <- ceiling(ponds$Depth[i])
  }
  ponds$Temp_anom[i] <- ponds$Temp[i] - clim_all$Temp[clim_all$Station.name == pond &
                                                      clim_all$Depth >= a &
                                                      clim_all$Depth <= b]
  ponds$DO_anom[i] <- ponds$DO[i] - clim_all$DO[clim_all$Station.name == pond &
                                                clim_all$Depth >= a &
                                                clim_all$Depth <= b]
}
```

```{r echo = FALSE, message = FALSE}
months <- ponds %>%
  group_by(Station.name, Date) %>%
  summarise(Month = mean(Month))

renderPlot({
  hist(months$Month[months$Station.name == input$pond], right = FALSE,
     breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), ylim = c(0, 32),
     main = "Months of sampling events", col = "lightblue",
     xlab = "Month", ylab = "Total sampling events")
})
```

### Nutrient levels

```{r echo = FALSE}
# load surface-only data
allSurface <- read.csv("data/AllPonds_Surface.csv")

sliderInput("xAxisMax", label = "X-axis maximum:", min = 0, max = 30, value = 30)
sliderInput("yAxisMax", label = "Y-axis maximum:", min = 0, max = 480, value = 480)

renderPlot({
  allSurface %>%
    filter(Station.name == input$pond) %>%
    filter(TP_flag == 2) %>%
    filter(TN_flag == 2) %>%
  ggplot(aes(x = TP, y = TN)) +
    geom_point(size = 2.5) +
    geom_abline(slope = 16/1, col = "black", linetype = "22", linewidth = 1) +
    scale_x_continuous(limits = c(0, input$xAxisMax)) +
    scale_y_continuous(limits = c(0, input$yAxisMax)) +
    labs(x = "TP (μM)", y = "TN (μM)") +
    theme_bw()
})
```

### Surface Chlorophyll vs. Secchi Depth

```{r echo = FALSE}
checkboxInput("line", "Show linear regression?", value = FALSE)

renderPlot({
  allSurface %>%
    filter(Station.name == input$pond) %>%
    filter(Chla_flag == 2) %>%
    filter(Secchi_flag == 2) %>%
  ggplot(aes(x = Chla, y = Secchi)) +
    geom_point(size = 2.5) +
    labs(x = "Chlorophyll (μg/L)", y = "Secchi Depth (m)") +
    theme_bw() +
    if(input$line) {
      model <- lm(Secchi ~ Chla, data = allSurface %>%
                                          filter(Station.name == input$pond) %>%
                                          filter(Chla_flag == 2) %>%
                                          filter(Secchi_flag == 2))
      list(geom_smooth(method = "lm", se = FALSE, col = "royalblue"),
           annotate("text",
                    x = min(allSurface$Chla[allSurface$Station.name == input$pond &
                                        allSurface$Chla_flag == 2]) + 0.25,
                    y = max(allSurface$Secchi[allSurface$Station.name == input$pond &
                                              allSurface$Secchi_flag == 2]) * 0.95,
                    label = paste0("y = ", round(summary(model)$coefficients[1], 3), " + ",
                                   round(summary(model)$coefficients[2], 3), "x"),
                    col = "royalblue"),
           annotate("text",
                    x = min(allSurface$Chla[allSurface$Station.name == input$pond &
                                        allSurface$Chla_flag == 2]) + 0.25,
                    y = max(allSurface$Secchi[allSurface$Station.name == input$pond &
                                              allSurface$Secchi_flag == 2]) * 0.92,
                    label = paste0("p = ", round(summary(model)$coefficients[2, 4], 3)),
                    col = "royalblue"))
    }
})
```

### Time-series analysis

#### Surface

```{r echo = FALSE}
# colnames(allSurface)[c(8:14, 16:18)] <- c("Secchi Depth (m)", "Temperature (°C)", "DO (mg/L)",
#                                           "DO_sat (%)", "pH", "Alkalinity (mg/L)", "TP (μM)",
#                                           "TN (μM)", "Chlorophyll-a (μg/L)", "Phaeophytin (μM)")

selectInput("param", label = "Choose parameter:", choices = colnames(allSurface)[c(13:19, 21:23)])
checkboxInput("MK", "Show Mann-Kendall trend?", value = FALSE)

renderPlot({
  flag_name <- paste0(input$param, "_flag")
  allSurface[allSurface$Station.name == input$pond &
             allSurface[[flag_name]] == 2, ] %>%
  ggplot(aes(x = Year, y = get(input$param))) +
    geom_point(size = 2.5) +
    labs(x = "Year", y = paste("Surface", input$param)) +
    theme_bw() +
    if(input$MK) {
      mk <- mk.test(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                              allSurface[[flag_name]] == 2])
      slope <- sens.slope(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                          allSurface[[flag_name]] == 2])$estimates
      intercept <- median(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                          allSurface[[flag_name]] == 2]) - 
                   median(allSurface$Year[allSurface$Station.name == input$pond &
                                          allSurface[[flag_name]] == 2]) * slope
      list(
        geom_abline(slope = slope, intercept = intercept, col = "black", linewidth = 1),
        annotate("text",
                 x = min(allSurface$Year[allSurface$Station.name == input$pond &
                                        allSurface[[flag_name]] == 2]) + 1,
                 y = max(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                              allSurface[[flag_name]] == 2]) * 0.95,
                 label = paste("slope =", round(slope, 3)), col = "black"),
        annotate("text",
                 x = min(allSurface$Year[allSurface$Station.name == input$pond &
                                        allSurface[[flag_name]] == 2]) + 1,
                 y = max(allSurface[[input$param]][allSurface$Station.name == input$pond &
                                                  allSurface[[flag_name]] == 2]) * 0.92,
                 label = paste("p =", round(mk$p.value, 3)), col = "black")
      )
    }
})
```

#### Bottom

```{r echo = FALSE}
# load bottom-only data
allBottom <- read.csv("data/AllPonds_Bottom.csv")

selectInput("param2", label = "Choose parameter:", choices = colnames(allBottom)[c(14:19, 21:23)])
checkboxInput("MK2", "Show Mann-Kendall trend?", value = FALSE)

renderPlot({
  flag_name <- paste0(input$param2, "_flag")
  p <- allBottom[allBottom$Station.name == input$pond &
            allBottom[[flag_name]] == 2, ] %>%
  ggplot(aes(x = Year, y = get(input$param2))) +
    geom_point(size = 2.5) +
    labs(x = "Year", y = paste("Bottom", input$param2)) +
    theme_bw()
  if(input$param2 == "DO") {
    p <- p + geom_hline(yintercept = 3, col = "firebrick3", linewidth = 1)
  }
  if(input$MK2) {
    mk <- mk.test(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                            allBottom[[flag_name]] == 2])
    slope <- sens.slope(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                        allBottom[[flag_name]] == 2])$estimates
    intercept <- median(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                        allBottom[[flag_name]] == 2]) - 
                 median(allBottom$Year[allBottom$Station.name == input$pond &
                                        allBottom[[flag_name]] == 2]) * slope
    p <- p +
      geom_abline(slope = slope, intercept = intercept, col = "black", linewidth = 1) +
      annotate("text",
               x = min(allBottom$Year[allBottom$Station.name == input$pond &
                                      allBottom[[flag_name]] == 2]) + 1,
               y = max(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                            allBottom[[flag_name]] == 2]) * 0.95,
               label = paste("slope =", round(slope, 3)), col = "black") +
      annotate("text",
               x = min(allBottom$Year[allBottom$Station.name == input$pond &
                                      allBottom[[flag_name]] == 2]) + 1,
               y = max(allBottom[[input$param2]][allBottom$Station.name == input$pond &
                                                allBottom[[flag_name]] == 2]) * 0.92,
               label = paste("p =", round(mk$p.value, 3)), col = "black")
  }
  p
})
```

### Profile plots

```{r echo = FALSE}
renderPlot({
  p1 <- ponds[ponds$Station.name == input$pond, ] %>%
    ggplot(aes(x = Temp, y = Depth)) +
      geom_point(size = 2.5, shape = 21) +
      scale_y_reverse() +
      labs(y = "Depth (m)") +
      theme_bw() +
      theme(panel.grid = element_blank())
  p2 <- ponds[ponds$Station.name == input$pond, ] %>%
    ggplot(aes(x = DO, y = Depth)) +
      geom_point(size = 2.5, shape = 21) +
      scale_y_reverse() +
      labs(y = "Depth (m)") +
      theme_bw() +
      theme(panel.grid = element_blank())
  ggarrange(p1, p2, ncol = 2)
})

DT::renderDataTable({
  ponds[ponds$Station.name == input$pond, c(1, 7:9, 12:15)] %>%
    rename(Date.Time = Date.Time..sampling.)
})
```

```{r echo = FALSE}
selectInput("param4", label = "Choose parameter:", choices = colnames(ponds)[12:13])

renderPlot({
  flag_name <- paste0(input$param4, "_flag")
  ponds[ponds$Station.name == input$pond &
        ponds[[flag_name]] == 2, ] %>%
  ggplot(aes(x = Year, y = Depth, fill = get(input$param4))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    scale_fill_gradientn(colors = parula(100), name = input$param4,
                         na.value = "white") +
    labs(y = "Depth (m)") +
    theme_bw() +
    theme(panel.grid = element_blank())
})
```

#### Anomaly plots

```{r echo = FALSE}
renderPlot({
  anom_name <- paste0(input$param4, "_anom")
  flag_name <- paste0(input$param4, "_flag")
  min <- -max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  max <- max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  p1 <- clim_all[clim_all$Station.name == input$pond, ] %>%
  ggplot(aes(x = Station.name, y = Depth, fill = get(input$param4))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    labs(y = "Depth (m)") +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    if(input$param4 == "Temp") {
      scale_fill_gradientn(colors = parula(100), name = input$param4,
                           limits = c(5, 28),
                           na.value = "white")
    } else if(input$param4 == "DO") {
      scale_fill_gradientn(colors = parula(100), name = input$param4,
                           limits = c(0, 15),
                           na.value = "white")
    }
  p2 <- ponds[ponds$Station.name == input$pond &
        ponds[[flag_name]] == 2, ] %>%
  ggplot(aes(x = Year, y = Depth, fill = get(anom_name))) +
    geom_point(size = 4, shape = 21) +
    scale_y_reverse() +
    scale_fill_gradientn(colors = coolwarm(100), name = anom_name,
                         limits = c(min, max), na.value = "white") +
    labs(y = "Depth (m)") +
    theme_bw() +
    theme(panel.grid = element_blank())
  ggarrange(p1, p2, widths = c(1, 10))
})

renderPlot({
  anom_name <- paste0(input$param4, "_anom")
  flag_name <- paste0(input$param4, "_flag")
  min <- -max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  max <- max(abs(ponds[[anom_name]][ponds$Station.name == input$pond & ponds[[flag_name]] == 2]))
  ponds[ponds$Station.name == input$pond &
        ponds[[flag_name]] == 2, ] %>%
  ggplot(aes(x = get(anom_name), y = Depth, group = Year, col = Year)) +
    geom_path() +
    geom_point() +
    scale_x_continuous(limits = c(min, max), name = anom_name) +
    scale_y_reverse() +
    scale_color_gradientn(colors = plasma(100)) +
    labs(y = "Depth (m)") +
    theme_bw() +
    theme(panel.grid = element_blank())
})
```

### Regional patterns in surface data

```{r echo = FALSE}
selectInput("prop1", label = "Choose x parameter:", choices = colnames(ponds)[c(12:13, 16:18, 20:22)])
selectInput("prop2", label = "Choose y parameter:", choices = colnames(ponds)[c(12:13, 16:18, 20:22)])
sliderInput("yearRange", label = "Year range:", min = 2001, max = 2023, value = c(2001, 2023))
```

#### Depth

```{r echo = FALSE}
renderPlot({
  flag_name1 <- paste0(input$prop1, "_flag")
  flag_name2 <- paste0(input$prop2, "_flag")
  allSurface[allSurface[[flag_name1]] == 2 &
             allSurface[[flag_name2]] == 2 &
             !is.na(allSurface$DepthClass) &
             allSurface$Year >= input$yearRange[1] &
             allSurface$Year <= input$yearRange[2], ] %>%
    mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
    mutate(BufferClass = factor(BufferClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
  ggplot(aes(x = get(input$prop1), y = get(input$prop2), col = BufferClass)) +
    geom_point(size = 2.5) +
    facet_wrap(~ DepthClass) +
    labs(x = input$prop1, y = input$prop2) +
    theme_bw() +
    theme(panel.grid = element_blank())
})
```

#### Buffer

```{r echo = FALSE}
renderPlot({
  flag_name1 <- paste0(input$prop1, "_flag")
  flag_name2 <- paste0(input$prop2, "_flag")
  allSurface[allSurface[[flag_name1]] == 2 &
             allSurface[[flag_name2]] == 2 &
             !is.na(allSurface$BufferClass) &
             allSurface$Year >= input$yearRange[1] &
             allSurface$Year <= input$yearRange[2], ] %>%
    mutate(DepthClass = factor(DepthClass, levels = c("Shallow", "Deep"))) %>%
    mutate(BufferClass = factor(BufferClass, levels = c("Very Low", "Low", "Medium", "High", "Very High"))) %>%
  ggplot(aes(x = get(input$prop1), y = get(input$prop2), col = DepthClass)) +
    geom_point(size = 2.5) +
    facet_wrap(~ BufferClass) +
    labs(x = input$prop1, y = input$prop2) +
    theme_bw() +
    theme(panel.grid = element_blank())
})
```

#### Size

```{r echo = FALSE}
renderPlot({
  flag_name1 <- paste0(input$prop1, "_flag")
  flag_name2 <- paste0(input$prop2, "_flag")
  allSurface[allSurface[[flag_name1]] == 2 &
             allSurface[[flag_name2]] == 2 &
             !is.na(allSurface$SizeClass) &
             allSurface$Year >= input$yearRange[1] &
             allSurface$Year <= input$yearRange[2], ] %>%
    mutate(SizeClass = factor(SizeClass, levels = c("Very Small", "Small", "Medium", "Large"))) %>%
  ggplot(aes(x = get(input$prop1), y = get(input$prop2))) +
    geom_point(size = 2.5) +
    facet_wrap(~ SizeClass) +
    labs(x = input$prop1, y = input$prop2) +
    theme_bw() +
    theme(panel.grid = element_blank())
})

prop1 <- "Temp"
prop2 <- "DO"

flag_name1 <- paste0(prop1, "_flag")
  flag_name2 <- paste0(prop2, "_flag")
  allSurface[allSurface[[flag_name1]] == 2 &
             allSurface[[flag_name2]] == 2 &
             !is.na(allSurface$SizeClass) &
             allSurface$Year >= 2001 &
             allSurface$Year <= 2020, ] %>%
    mutate(SizeClass = factor(SizeClass, levels = c("Very Small", "Small", "Medium", "Large"))) %>%
  ggplot(aes(x = get(prop1), y = get(prop2))) +
    geom_point(size = 2.5) +
    facet_wrap(~ SizeClass) +
    labs(x = prop1, y = prop2) +
    theme_bw() +
    theme(panel.grid = element_blank())
```

### Cape Cod-wide maps

#### TN:TP ratios

Most recent year of data from every pond:
```{r echo = FALSE, message = FALSE}
# turn off spherical geometry to avoid "duplicate" errors
sf_use_s2(FALSE)

# get Massachusetts outline
mass <- read_sf("/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/gshhg-shp-2.3.7/GSHHS_shp/f/GSHHS_f_L1.shp") %>%
  st_make_valid() %>%
  st_crop(xmin = -71, xmax = -69, ymin = 41, ymax = 42.25)

renderPlot({
  surface_recent <- allSurface %>%
    group_by(Station.number) %>%
    filter(Year == max(Year))
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = surface_recent[!is.na(surface_recent$TP), ], aes(x = Long, y = Lat,
                                                                       col = log10(TN / TP)),
               size = 2.5) +
    scale_color_gradientn(colors = rev(parula(100)), name = "TN:TP", trans = "log10",
                          limits = c(1, 3.3), breaks = c(1, 2, 3), labels = c(10, 100, 1000)) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(axis.title = element_blank())
})
```

Aug-Sept average of years 2016-2023:
```{r echo = FALSE, warning = FALSE}
renderPlot({
  surface_recent <- allSurface %>%
    filter(Year >= 2016)
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = surface_recent[!is.na(surface_recent$TP), ], aes(x = Long, y = Lat,
                                                                       col = log10(TN / TP)),
               size = 2.5) +
    scale_color_gradientn(colors = rev(parula(100)), name = "TN:TP", trans = "log10",
                          limits = c(1, 3.3), breaks = c(1, 2, 3), labels = c(10, 100, 1000)) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(axis.title = element_blank())
})
```

#### Mix and match
Aug-Sept average of years 2016-2023.

```{r echo = FALSE}
selectInput("layer", label = "Choose layer:", choices = c("Surface", "Bottom"))
selectInput("param3", label = "Choose parameter:", choices = colnames(allSurface)[c(14:19, 21:23)])

renderPlot({
  if(input$layer == "Surface") {
    data_recent <- allSurface %>%
    filter(Year >= 2016)
  } else {
    data_recent <- allBottom %>%
    filter(Year >= 2016)
  }
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = data_recent[!is.na(data_recent[[input$param3]]), ],
                 aes(x = Long, y = Lat, col = get(input$param3)),
                 size = 2.5) +
    scale_color_viridis(option = "plasma", name = paste(input$layer, input$param3)) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(axis.title = element_blank())
})
```

#### Regional patterns in surface anomalies

```{r echo = FALSE}
selectInput("param5", label = "Choose parameter:", choices = colnames(ponds)[12:13])
sliderInput("year", label = "Year:", min = 2001, max = 2020, value = 2020)

renderPlot({
  anom_name <- paste0(input$param5, "_anom")
  flag_name <- paste0(input$param5, "_flag")
  #min <- -max(abs(ponds[[anom_name]][ponds[[flag_name]] == 2]), na.rm = TRUE)
  #max <- max(abs(ponds[[anom_name]][ponds[[flag_name]] == 2]), na.rm = TRUE)
  min <- ifelse(anom_name == "Temp_anom", -10, -15)   # temp_anom range [-10, 10]; DO_anom range [-15, 15]
  max <- ifelse(anom_name == "Temp_anom", 10, 15)
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = ponds[ponds[[flag_name]] == 2 &
                            ponds$Year == input$year &
                            ponds$Depth <= 1.0, ],
               aes(x = Long, y = Lat, fill = get(anom_name), size = abs(get(anom_name))), shape = 21) +
    scale_fill_gradientn(colors = coolwarm(100), name = anom_name,
                         limits = c(min, max), na.value = "white") +
    scale_size_continuous(range = c(2, 6), name = paste(anom_name, "\nmagnitude"),
                          limits = c(0, max)) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank())
})
```

#### Surface trends over time

```{r echo = FALSE}
slopes_surf <- data.frame(rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)))
colnames(slopes_surf) <- c("pond", "Long", "Lat", colnames(allSurface)[c(13:19, 21:23)])

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_surf$pond[i] <- pond
  oneSurf <- allSurface[allSurface$Station.name == pond &
                        allSurface[[flag_name]] == 2, ]
  slopes_surf$Long[i] <- oneSurf$Long[1]
  slopes_surf$Lat[i] <- oneSurf$Lat[1]
  if(nrow(oneSurf) < 3) {
    next
  }
  year.1 <- min(oneSurf$Year)
  year.n <- max(oneSurf$Year)
  if(nrow(oneSurf) < (year.n - year.1)/2) {
    next
  }
  for(param in colnames(allSurface)[c(13:19, 21:23)]) {
    if(is.na(sum(oneSurf[[param]]))) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneSurf[[param]])
    if(mk$p.value > 0.1) {
      next
    }
    slopes_surf[[param]][i] <- sens.slope(oneSurf[[param]])$estimates
  }
}

slopes_bott <- data.frame(rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)),
                          rep(NA, length(pondName)))
colnames(slopes_bott) <- c("pond", "Long", "Lat", colnames(allBottom)[c(13:19, 21:23)])

for(i in 1:length(pondName)) {
  pond <- pondName[i]
  slopes_bott$pond[i] <- pond
  oneBott <- allBottom[allBottom$Station.name == pond &
                       allBottom[[flag_name]] == 2, ]
  slopes_bott$Long[i] <- oneBott$Long[1]
  slopes_bott$Lat[i] <- oneBott$Lat[1]
  if(nrow(oneBott) < 3) {
    next
  }
  year.1 <- min(oneBott$Year)
  year.n <- max(oneBott$Year)
  if(nrow(oneBott) < (year.n - year.1)/2) {
    next
  }
  for(param in colnames(allBottom)[c(13:19, 21:23)]) {
    if(is.na(sum(oneBott[[param]]))) {
      next
    }
    flag_name <- paste0(param, "_flag")
    mk <- mk.test(oneBott[[param]])
    if(mk$p.value > 0.1) {
      next
    }
    slopes_bott[[param]][i] <- sens.slope(oneBott[[param]])$estimates
  }
}
```

```{r echo = FALSE}
selectInput("param6", label = "Choose parameter:", choices = colnames(allSurface)[c(13:19, 21:23)])

renderPlot({
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = slopes_surf,
               aes(x = Long, y = Lat, size = abs(get(input$param6)), fill = factor(sign(get(input$param6)))),
               shape = 21) +
    scale_size_continuous(range = c(2, 6), name = paste(input$param6, "trend\nmagnitude")) +
    scale_fill_discrete(type = c("firebrick", "royalblue"), labels = c("negative", "positive"),
                        name = paste(input$param6, "trend\ndirection"),
                        na.translate = FALSE) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank())
})
```

#### Bottom trends over time

```{r echo = FALSE}
selectInput("param7", label = "Choose parameter:", choices = colnames(allBottom)[c(14:19, 21:23)])

renderPlot({
  ggplot() +
    geom_sf(data = mass) +
    geom_point(data = slopes_bott,
               aes(x = Long, y = Lat, size = abs(get(input$param7)), fill = factor(sign(get(input$param7)))),
               shape = 21) +
    scale_size_continuous(range = c(2, 6), name = paste(input$param7, "trend\nmagnitude")) +
    scale_fill_discrete(type = c("firebrick", "royalblue"), labels = c("negative", "positive"),
                        name = paste(input$param7, "trend\ndirection"),
                        na.translate = FALSE) +
    xlim(-70.65, -69.95) +
    ylim(41.55, 42.07) +
    theme_bw() +
    theme(panel.grid = element_blank(),
          axis.title = element_blank())
})
```
